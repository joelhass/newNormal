# 6/12/2020
# Updated GradNormal Algorithm Python program
# compute  normal surface generated by a  Goldberg tiling
# Adapted to handle Stanford Bunny

# This python program is meant only as a proof of concept
# There is much room to improve running time and efficiency
# It is not set up to input general surfaces or for general usage

# The output of this program is three .off files
# surfacePts.off   - output of MidNormal algorithm for given a
# noquadSurfacePts.off - adjusts gsurfacePts.off as in GradNormal algorithm by
# replacing 4 triangles neighboring valence four vertices with 2 triangles.

from numpy.linalg import norm
import sys
import math
import trimesh
import numpy as np
from region_definition import get_region_map, parse_off_file
from resize_off_to_unit_cube import resize_off_to_unit_cube, expand_off_to_original_dimenstions
import pdb
import collections

from geometric_objects import Point, Triangle

VERTICAL_SCALE = math.sqrt(2.) / 4.  # Vertical scale. approx 0.35355 from paper - use for GradNorm1
PI = math.pi
SQRT3 = math.sqrt(3.)  # square root of 3
NO_QUADS_INTERMEDIATE_FILENAME = "noquadSurfacePts.off"
OUTPUT_FILENAME = "out.off"
RESIZED_OUTPUT_FILENAME = "resized_out.off"
TRANSLATION_PREFIX = "translated_"
FINAL_OUTPUT_PREFIX = "nn_"

def main():
    # NT  = Number of tetrahedra
    # Will create a tiling of the unit cube by 6*NT^3 tetrahedra
    NT = int(sys.argv[1])
    (Nx, Ny, Nz) = getGridBounds(NT)
    (dx, dy, dz) = getGridSpacing(NT)

    # Expected input file is any enclosed triangulated surface with no holes
    file_name = sys.argv[2]

    # Translate the input off file to the unit cube, creating a new file named translated_<original_filename>
    # We save the stretch factor so we can move it back to it's original size later.
    translated_file_name = TRANSLATION_PREFIX + file_name
    (stretch_factor, xMin, yMin, zMin) = resize_off_to_unit_cube(file_name, translated_file_name)

    # Use the translated file to get a region map, where points inside the surface have value
    # -1 and points outside the surface have value 1
    region_def = get_region_map(NT, translated_file_name)

    # Run the midnormal algorithm on the region definition
    midnormal_surface_mesh = generate_midnormal_mesh(*getGridBounds(NT), *getGridSpacing(NT), region_def)
    # with open("midnormal.off", "w") as midnormal_out_file:
    #     midnormal_out_file.write(trimesh.exchange.off.export_off(midnormal_surface_mesh))

    # Remove quads from the midnormal mesh
    no_quad_surface_mesh = remove_quads_from_mesh(midnormal_surface_mesh)

    # Get largest connected component
    all_meshes = no_quad_surface_mesh.split()
    no_quad_surface_mesh = max(all_meshes, key=lambda m: len(m.vertices))

    with open(NO_QUADS_INTERMEDIATE_FILENAME, "w") as no_quad_surface_file:
        no_quad_surface_file.write(trimesh.exchange.off.export_off(no_quad_surface_mesh))


    displace_to_surface(translated_file_name, NO_QUADS_INTERMEDIATE_FILENAME, OUTPUT_FILENAME)
    
    resized_output_filename = FINAL_OUTPUT_PREFIX + file_name

    expand_off_to_original_dimenstions(OUTPUT_FILENAME, resized_output_filename, 1.0/stretch_factor, xMin, yMin, zMin)

    print(" Angles for original .off file")
    get_triangle_angle_histogram(translated_file_name)
    print(" Angles for projected .off file")
    get_triangle_angle_histogram(OUTPUT_FILENAME)


def getGridBounds(NT):
    Nx = NT + 1  # x-direction triangle count.  1 extra needed
    Ny = int(math.ceil(NT * 2 / SQRT3))  # y-direction triangle count
    # z-direction count of tetrahedra stacked above a triangle
    Nz = int(math.ceil(float(NT) / (3. * VERTICAL_SCALE) + 1))

    return (Nx, Ny, Nz)


def getGridSpacing(NT):
    dx = 1. / float(NT)
    dy = dx * SQRT3 / 2.
    dz = 3. * VERTICAL_SCALE / float(NT)

    return (dx, dy, dz)

def level_f(region_def, Nx, Ny, Nz, dx, dy, dz, x, y, z):  # x,y,z in [0,1]^3
    jj = max(int(round(y / dy)), 0)
    jj = min(jj, Ny - 1)
    ii = max(int(round(x / dx + (jj % 2) / 2.)), 0)
    ii = min(ii, Nx - 1)
    kk = max(int(round(z / dz - (ii % 3) / 3. + 1 - (jj % 2) / 3.)), 0)
    kk = min(kk, Nz - 1)
    return region_def[(ii, jj, kk)]

def bounded_region_def(region_def, Nx, Ny, Nz, i, j, k):
    i = max(i, 0)
    i = min(i, Nx - 1)
    j = max(j, 0)
    j = min(j, Ny - 1)
    k = max(k, 0)
    k = min(k, Nz - 1)
    return region_def[(i, j, k)]

##########################################################################

# Writes the triangle, and the displaced triangle defined by points p1, p2, p3 to
# the given files.

# Creates the triangles for the midnormal, using the region definition. Returns triangle count.
def generate_midnormal_mesh(Nx, Ny, Nz, dx, dy, dz, region_def):
    # mesh = trimesh.Trimesh(vertices, faces)
    vertices = []
    faces = []

    triangle_index = 0 

    def write_triangle(p1, p2, p3):
        nonlocal faces
        nonlocal vertices
        nonlocal triangle_index

        vertices += [[p1.x, p1.y, p1.z], [p2.x, p2.y, p2.z], [p3.x, p3.y, p3.z]]
        faces += [[triangle_index, triangle_index+1, triangle_index+2]]
        triangle_index += 3

    NumTets = 0  # Number of tetrahedra used to tile I^3

    print("starting main loop")
    for i in range(Nx):
        if i % 5 == 0:
            print(f'{i}/{Nx}')
        for j in range(Ny):
            for k in range(Nz):  # x,y,z coordinates of i,j,k lattice point
                A = Point.create_from_grid_coordinates(i, j, k, dx, dy, dz)
                B = Point.create_from_grid_coordinates(i, j, k + 1, dx, dy, dz)

                fA = bounded_region_def(region_def, Nx, Ny, Nz, i, j, k)
                fB = bounded_region_def(region_def, Nx, Ny, Nz, i, j, k + 1)

                # x,y,z coordinates for four vertices A,B,C,D of six tetrahedra whose lowest z coordinate vertex is at P
                # z coordinates have A < C < D < B
                # TODO: Write tetrahedra class, should move this logic there.

                for l in range(6):
                    NumTets += 1.
                    if l % 2:  # if l is odd.
                        C_x = A.x + math.cos(float(l + 1) * PI / 3.) * dx
                        C_y = A.y + math.sin(float(l + 1) * PI / 3.) * dx
                        D_x = A.x + math.cos(float(l) * PI / 3.) * dx
                        D_y = A.y + math.sin(float(l) * PI / 3.) * dx
                    else:  # if l  even
                        C_x = A.x + math.cos(float(l) * PI / 3.) * dx
                        C_y = A.y + math.sin(float(l) * PI / 3.) * dx
                        D_x = A.x + math.cos(float(l + 1) * PI / 3.) * dx
                        D_y = A.y + math.sin(float(l + 1) * PI / 3.) * dx
                    C_z = A.z + dz / 3.
                    D_z = A.z + 2 * dz / 3.

                    C = Point(C_x, C_y, C_z)
                    D = Point(D_x, D_y, D_z)

                    # Now evaluate function levelf at vertices.
                    fC = level_f(region_def, Nx, Ny, Nz, dx, dy, dz, C.x, C.y, C.z)
                    fD = level_f(region_def, Nx, Ny, Nz, dx, dy, dz, D.x, D.y, D.z)
                    # Find x,y,z coordinates for edge midpoints
                    K = Point.midpoint(A, B)
                    L = Point.midpoint(A, C)
                    M = Point.midpoint(A, D)
                    N = Point.midpoint(B, C)
                    P = Point.midpoint(C, D)
                    Q = Point.midpoint(B, D)
                    # if (fA >= 0 and fB >= 0 and fC >= 0 and fD >= 0) or (
                    #         fA < 0 and fB < 0 and fC < 0 and fD < 0):
                    #     # no triangles added for this one sign tetrahedron - treat
                    #     # 0 as positive
                    if (fA >= 0 and fB < 0 and fC < 0 and fD < 0) or (fA < 0 and fB >= 0 and fC >= 0 and fD >= 0):
                        # Case of triangle near vertex A
                        write_triangle(K, L, M)
                    elif (fB >= 0 and fA < 0 and fC < 0 and fD < 0) or (fB < 0 and fA >= 0 and fC >= 0 and fD >= 0):
                        # Case of triangle near vertex B
                        write_triangle(K, N, Q)
                    elif (fC >= 0 and fA < 0 and fB < 0 and fD < 0) or (fC < 0 and fB >= 0 and fA >= 0 and fD >= 0):
                        # Case of triangle near vertex C
                        write_triangle(P, N, L)
                    elif (fD >= 0 and fA < 0 and fB < 0 and fC < 0) or (fD < 0 and fB >= 0 and fA >= 0 and fC >= 0):
                        # Case of triangle near vertex D
                        write_triangle(P, M, Q)
                    elif (fA >= 0 and fB >= 0 and fC < 0 and fD < 0) or (fA < 0 and fB < 0 and fC >= 0 and fD >= 0):
                        # Case of quadrilateral LMNQ separating AB, CD
                        write_triangle(L, M, N)
                        write_triangle(M, N, Q)
                    elif (fA >= 0 and fC >= 0 and fB < 0 and fD < 0) or (fA < 0 and fC < 0 and fB >= 0 and fD >= 0):
                        # Case of quadrilateral KMPN separating AC, BD
                        write_triangle(K, M, N)
                        write_triangle(M, N, P)
                    elif(fA >= 0 and fD >= 0 and fC < 0 and fB < 0) or (fA < 0 and fD < 0 and fC >= 0 and fB >= 0):
                        # Case of quadrilateral KLPQ separating AD, CB used for our a=0.47  Use KLP and KPQ for a=0.47.
                        #                 if a = math.sqrt(2)/4:  # Use KLP and KPQ
                        write_triangle(K, L, P)
                        write_triangle(K, P, Q)

    print("Number of Tetrahedra used to tile the unit cube was: ", NumTets)

    return trimesh.Trimesh(vertices, faces)

def remove_quads_from_mesh(input_mesh):
    vertices = input_mesh.vertices
    faces = input_mesh.faces
    v = len(vertices)
    f = len(faces)
    valences = [0 for i in range(len(vertices))]  # list of [vertex_i_valence]

    for face in faces:
        for point in face:
            valences[point] += 1

    valence_4_point_indexes = []  # list of valence 4 points

    for i in range(len(valences)):
        if valences[i] == 4:
            valence_4_point_indexes.append(i)

    num4Pts = len(valence_4_point_indexes)

    # who are my neighbors?
    neighbors = [set() for i in range(len(vertices))]  # one set for each vertex
    for i in range(f):
        for j in range(3):
            currentV = faces[i][j]  # vertex of ith triangle
            neighbors[currentV] |= set(faces[i])  # set union
    for i in range(0, v):  # not my own neighbor
        neighbors[i].discard(i)

    # For a face that is a quad, identify its good diagonal, the one not
    # between two valence 6 vertices
    newTriang = [[0, 0, 0]]

    for i in range(len(valence_4_point_indexes)):  # of vertices
        qv = list(neighbors[valence_4_point_indexes[i]])  # work with list of four neighbors
        if qv[0] in neighbors[qv[1]] and qv[0] in neighbors[qv[2]]:  # diag is 0,3 or 1,2
            if valences[qv[0]] > 6 or valences[qv[3]] > 6:     # diag 1,2
                newTriang.append([qv[0], qv[1], qv[2]])
                newTriang.append([qv[1], qv[2], qv[3]])
            else:  # diag  0,3
                newTriang.append([qv[0], qv[1], qv[3]])
                newTriang.append([qv[0], qv[2], qv[3]])
        elif qv[0] in neighbors[qv[1]] and qv[0] in neighbors[qv[3]]:  # diags are 0,2 and 1,3
            if valences[qv[0]] > 6 or valences[qv[2]] > 6:  # diag  1,3
                newTriang.append([qv[0], qv[1], qv[3]])
                newTriang.append([qv[1], qv[2], qv[3]])
            else:  # diag  0,2
                newTriang.append([qv[0], qv[2], qv[3]])
                newTriang.append([qv[0], qv[1], qv[2]])
        else:  # diags are 0,1 and 2,3
            if valences[qv[0]] > 6 or valences[qv[1]] > 6:  # diag 2,3
                newTriang.append([qv[1], qv[2], qv[3]])
                newTriang.append([qv[0], qv[2], qv[3]])
            else:  # diag 0,1
                newTriang.append([qv[0], qv[1], qv[2]])
                newTriang.append([qv[0], qv[1], qv[3]])
    del newTriang[0]  # delete unneeded initial triangle used to initialize

    # no_quad_faces will contain all triangle vertices after adding diagonals to quads
    # vertex of valence > 6
    no_quad_faces = []
    count = 0
    for i in range(len(faces)):
        k = faces[i]
        if (valences[k[0]] != 4) and (valences[k[1]]) != 4 and (
                valences[k[2]] != 4):  # if triangle has no valence 4 vertex
            no_quad_faces.append(k)
            count += 1
    # now add new triangles to no_quad_faces
    for i in range(len(newTriang)): 
        no_quad_faces.append(newTriang[i])

    return trimesh.Trimesh(vertices, no_quad_faces)

def displace_to_surface(original_surface_file, surface_to_project_file, output_filename):
    projected_filename = output_filename

    (points, _to_project_triangles) = parse_off_file(surface_to_project_file)
    mesh = trimesh.load(original_surface_file)

    formatted_points = list(map(lambda p: [p.x, p.y, p.z], points))

    (closest_points, distances, triangle_id) = mesh.nearest.on_surface(formatted_points)

    with open(surface_to_project_file, 'r') as to_displace_file:
        with open(projected_filename, 'w') as projected_file:
            for index, line in enumerate(to_displace_file):
                if index == 0:
                    projected_file.write(line)
                elif index == 1:
                    count_info = line.split(' ')
                    vertice_count = int(count_info[0])
                    projected_file.write(line)
                elif index < 2 + vertice_count:
                    projected_file.write(' '.join(str(elem)
                                                  for elem in closest_points[index - 2]))
                    projected_file.write('\n')
                else:
                    projected_file.write(line)


def get_triangle_angle_histogram(file_name):
    mesh = trimesh.load(file_name)
    angles = trimesh.triangles.angles(mesh.triangles)
    degree_counts = collections.defaultdict(int)

    min_angle = 180.0
    max_angle = 0.0

    for triangle_angle in angles:
        for vert_angle in triangle_angle:
            precise_angle = (vert_angle * 180.0 / PI)
            min_angle = min(precise_angle, min_angle)
            max_angle = max(precise_angle, max_angle)
            angle = int(vert_angle * 180.0 / PI)
            degree_counts[angle] += 1

    print("min_angle: %s" % (min_angle))
    print("max_angle: %s" % (max_angle))
    for i in range(181):
        if i in degree_counts:
            print("%s, %s" % (i, degree_counts[i]))
        else:
            print("%s, %s" % (i, 0))
    return degree_counts

if __name__ == '__main__':
    main()
